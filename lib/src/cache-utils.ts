import { IImageOptions } from "docx";
import { openDB } from "idb";
import { Image, SVG } from "@m2d/core";
import { IDefaultImagePluginOptions, ImageResolver } from ".";
import xxhash from "xxhash-wasm";

/** IndexedDB database name used for persistent image caching */
const DB_NAME = "m2d-image-cache";

/** IndexedDB object store name for storing image render results */
const STORE_NAME = "images";

/**
 * Opens the IndexedDB database and creates the object store if it doesn't exist.
 * This promise is reused across the module to avoid reopening the DB multiple times.
 */
const dbPromise = openDB(DB_NAME, 1, {
  upgrade(db) {
    if (!db.objectStoreNames.contains(STORE_NAME)) {
      db.createObjectStore(STORE_NAME);
    }
  },
});

/**
 * Stable stringify implementation to create consistent, deterministic string
 * representations of plugin options for cache key generation.
 *
 * @internal Removes non-cacheable fields like `imageResolver`.
 */
const stableStringify = (obj: Record<string, unknown>) => {
  delete obj.imageResolver;
  const keys = Object.keys(obj).sort();
  return keys.map(key => `${key}:${obj[key]}`).join("|");
};

/** In-memory runtime cache for de-duping parallel requests */
const cache: Record<string, Promise<IImageOptions>> = {};

/**
 * Generates a deterministic hash key based on image source and plugin options.
 * Used for persistent image caching and avoiding redundant processing.
 *
 * @param src - The original image source (URL, base64, etc.)
 * @param options - The image plugin options affecting rendering
 * @param node - Optional AST node (used to extract SVG or mermaid source)
 * @returns A unique, stable hash string representing the image + options combo
 */
export const generateCacheKey = async (
  src: string,
  options: IDefaultImagePluginOptions,
  node?: Image | SVG,
): Promise<string> => {
  const { h64ToString } = await xxhash();

  const fingerprint = node?.type === "svg" ? (node.data?.mermaid ?? String(node.value)) : src;

  const keyData = fingerprint + stableStringify(options as unknown as Record<string, unknown>);
  return h64ToString(keyData);
};

/**
 * Creates a caching wrapper around an image resolver. This ensures that
 * expensive image processing (e.g., base64 conversion or SVG rendering)
 * is only performed once per unique input.
 *
 * Cached results are stored in memory and in IndexedDB for persistent reuse.
 *
 * @param imageResolver - The original image resolver function
 * @returns A wrapped resolver with automatic persistent caching
 */
export const createCachedImageResolver =
  (imageResolver: ImageResolver): ImageResolver =>
  async (src, options, node) => {
    const cacheKey = await generateCacheKey(src, options, node);

    cache[cacheKey] ??= (async () => {
      const cached = await loadImage(cacheKey);
      if (cached) return cached;

      const result = await imageResolver(src, options, node);
      cacheImage(cacheKey, result);
      return result;
    })();

    return cache[cacheKey];
  };

/**
 * Loads a previously cached image (if available) from IndexedDB.
 *
 * @param key - Cache key generated by `generateCacheKey`
 * @returns The stored image options or `undefined` if not found
 */
export const loadImage = async (key: string): Promise<IImageOptions | undefined> => {
  try {
    const db = await dbPromise;
    return await db.get(STORE_NAME, key);
  } catch (err) {
    console.warn("[m2d:image-cache] Failed to read from IndexedDB", err);
  }
};

/**
 * Stores image options in the IndexedDB for future retrieval.
 *
 * @param key - Unique hash representing the image and options
 * @param value - The rendered image metadata to cache
 */
export const cacheImage = async (key: string, value: IImageOptions): Promise<void> => {
  try {
    const db = await dbPromise;
    await db.put(STORE_NAME, value, key);
  } catch (err) {
    console.warn("[m2d:image-cache] Failed to write to IndexedDB", err);
  }
};

/**
 * Clears all cached image entries from IndexedDB.
 * This does not affect the in-memory cache.
 */
export const clearImageCache = async (): Promise<void> => {
  try {
    const db = await dbPromise;
    await db.clear(STORE_NAME);
  } catch (err) {
    console.warn("[m2d:image-cache] Failed to clear IndexedDB", err);
  }
};
