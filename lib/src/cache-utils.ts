import { IImageOptions } from "docx";
import { Image, SVG } from "@m2d/core";
import { IDefaultImagePluginOptions, ImageResolver } from ".";
import xxhash from "xxhash-wasm";

/** IndexedDB database name used for persistent image caching */
const DB_NAME = "m2d-image-cache";

/** DB Version */
const DB_VERSION = 1;

/** IndexedDB object store name for storing image render results */
const STORE_NAME = "images";

/* v8 ignore start - indexDB not available in test env */
/**
 * Opens the IndexedDB database and creates the object store if it doesn't exist.
 * This promise is reused across the module to avoid reopening the DB multiple times.
 */
const openDB = (): Promise<IDBDatabase> =>
  new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains(STORE_NAME))
        db.createObjectStore(STORE_NAME, { keyPath: "id" });
    };

    request.onsuccess = () => resolve(request.result);

    request.onerror = () => reject(request.error);
  });

/**
 * Loads a previously cached image (if available) from IndexedDB.
 *
 * @param key - Cache key generated by `generateCacheKey`
 * @returns The stored image options or `undefined` if not found
 */
export const loadImage = (key: string): Promise<IImageOptions | undefined> =>
  openDB()
    .then(db => {
      return new Promise<IImageOptions | undefined>((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(key);

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    })
    .catch(err => {
      console.warn("[m2d:image-cache]", err);
      return undefined;
    });

/**
 * Stores image options in the IndexedDB for future retrieval.
 *
 * @param id - Unique hash representing the image and options
 * @param value - The rendered image metadata to cache
 */
export const cacheImage = (id: string, value: IImageOptions): Promise<void> =>
  openDB()
    .then(db => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      store.put({ id, ...value });

      return new Promise<void>((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject();
      });
    })
    .catch(err => {
      console.warn("[m2d:image-cache]", err);
    });

/* v8 ignore end */

/**
 * Stable stringify implementation to create consistent, deterministic string
 * representations of plugin options for cache key generation.
 *
 * @internal Removes non-cacheable fields like `imageResolver`.
 */
const stableStringify = (obj: Record<string, unknown>) => {
  delete obj.imageResolver;
  const keys = Object.keys(obj).sort();
  return keys.map(key => `${key}:${obj[key]}`).join("|");
};

/** In-memory runtime cache for de-duping parallel requests */
const cache: Record<string, Promise<IImageOptions>> = {};

/**
 * Generates a deterministic hash key based on image source and plugin options.
 * Used for persistent image caching and avoiding redundant processing.
 *
 * @param src - The original image source (URL, base64, etc.)
 * @param options - The image plugin options affecting rendering
 * @param node - Optional AST node (used to extract SVG or mermaid source)
 * @returns A unique, stable hash string representing the image + options combo
 */
export const generateCacheKey = async (
  src: string,
  options: IDefaultImagePluginOptions,
  node?: Image | SVG,
): Promise<string> => {
  const { h64ToString } = await xxhash();

  const fingerprint = node?.type === "svg" ? (node.data?.mermaid ?? String(node.value)) : src;

  const keyData = fingerprint + stableStringify(options as unknown as Record<string, unknown>);
  return h64ToString(keyData);
};

/**
 * Creates a caching wrapper around an image resolver. This ensures that
 * expensive image processing (e.g., base64 conversion or SVG rendering)
 * is only performed once per unique input.
 *
 * Cached results are stored in memory and in IndexedDB for persistent reuse.
 *
 * @param imageResolver - The original image resolver function
 * @returns A wrapped resolver with automatic persistent caching
 */
export const createCachedImageResolver =
  (imageResolver: ImageResolver): ImageResolver =>
  async (src, options, node) => {
    const cacheKey = await generateCacheKey(src, options, node);

    cache[cacheKey] ??= (async () => {
      const cached = await loadImage(cacheKey);
      if (cached) return cached;

      const result = await imageResolver(src, options, node);
      cacheImage(cacheKey, result);
      return result;
    })();

    return cache[cacheKey];
  };
